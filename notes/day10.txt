- 배열 -> 여러 개의 값을 담을 메모리 / 변수 목록

	-선언 방법 => type [ ] 변수명 = new type [5] ;
			변수명[] = { , , , ,};
		ex) int [] number = new int[4];
		     int [] number = new int[] {1,2,3,4};
		     int [] number = {1,2,3,4};

		    int 

			* - type [] 변수명; -> 선언 가능
			  - 값 저장 안 해도 출력 가능 (null값)

* 상수
	- 변수의 값을 고정
		ex) final int A = 100;
 			-> final로 고정 시 구분을 위해 변수명은 대문자 (띄어쓰기는 _로 대체)

				
		
* 변수의 종류
	
public class Example {

   int a;  ---> 인스턴스 변수   			

   static int b; ---> 클래스 변수

	publuc static void main(String [] args /*로컬변수 = 파라미터*/) {
		
		int c; ---> 로컬 변수
	}
}	


	- 인스턴스 변수 (instance variable)
		-> new 명령을 사용하여 인스턴스를 생성할 때 준비되는 변수

	- 클래스 변수 (class variable = static variable)
		 -> 클래스가 로딩될 때 준비되는 변수

	- 로컬 변수 (local variable)
		 -> 블록을 실행할 때 준비되는 변수

	- 파라미터 (parameter) 
		-> 메서드의 아규먼트를 받는 로컬 변수이다.	
			(위의 코드에서 main()의 args 로컬 변수)

*종류에 따른 변수의 사용 범위

public class Example2 {
	int a;  --> 인스턴스 변수

	static int b; --> 클래스 변수

	public static void main(String[] args) {
		int c; --> 로컬 변수

		b = 20; --> static이 붙은 블록 (static method = class method)에서는
			   그 블록 바깥 쪽에 있는 스태틱 변수(클래스 변수)를 사용할 수 있다.

		a = 100; // 오류! --> 그러나 static이 붙지 않은 인스턴스 변수는 사용할 수 없다!!			    
	}
	
	public static void m2(){
		b = 20; --> static이 붙은 블록 (static method = class method)에서는
			   그 블록 바깥 쪽에 있는 스태틱 변수(클래스 변수)를 사용할 수 있다.
	
		a = 100; // 오류! --> 그러나 static이 붙지 않은 인스턴스 변수는 사용할 수 없다!!

		c = 100; // 오류! --> 다른 메서드에 선언된 로컬 변수를 사용할 수 없다
		System.out.println(args[0]); --> 다른 메서드에 선언된 로컬 변수를 사용할 수 없다
	}	

	public void m3() {
		// static 이 붙지 않은 블록에서는 
		    그 블록 바깥 쪽에 선언된 변수를 모두 접근할 수 있다.
		b= 20;  --> ok
		a =100; --> ok
		c = 100; // 오류! --> 다른 메서드에 선언된 로컬 변수를 사용할 수 없다
		System.out.println(args[0]); --> 다른 메서드에 선언된 로컬 변수를 사용할 수 없다
	}			
}

- 형 변환

	정수 --> 부동소수점
		byte(1) -> float(4)
		short(2) -> float(4)		-----> OK!!
		char(2) -> float(4)
		int(4) -> double(8)

		int(4) -> flot(4)
		long(8) -> float(4)		----> 유효자릿수 넘으면 짤림 / 컴파일 오류 안나므로 주
		long(8) -> double(8)  	

	부동소수점 -> 정수
		=> 정수는 소수점 이하 저장 못하므로 컴파일 오류!
		
		이를 해결하기 위해 명시적 형 변환 실행

	-명시적 형 변환
	       -> 안될걸 알지만 강제적으로 값을 넣음
		
		1. 부동소수점 -> 정수
			- float -> int
				ex) float a = 3.14f;
		    		 int i = (int) a; <- 소수점 이하 제거

			- double -> long
				ex) double d = 9876.56789;
				     long l = (long)d; <- 소수점 이하 제거

		2.큰 정수 -> 작은 정수
			1) 큰 메모리 값이 작은 메모리에 들어가는 경우
				ex) bye b = 100;
				     short s = 100;
				     int i = 100;
				     long l = 100;
		
				    byte b2 = (byte) s ;
				           b2 = (byte) i ;
				           b2 = (byte) l ;

			2) 큰 메모리 값이 작은 메모리에 못 들어가는 경우
				ex) int i2 = 300;
				     byte b2 = (byte) i2 ;
				    
				     i2를 출력하면 300이 아닌 44가 나옴
					-> int i2 = 0b 0000_0000_0000_0000_0000_0001_0010_1100 (= 300)
						
						-> byte로 전환할 경우, 앞쪽 바이트 값을 날림
						
						=> 0010_1100 (=44)
			
			* 큰 값을 작은 메모리에 넣는 것은 무의미 !
			  다만, 큰 메모리 값을 바이트 단위로 쪼개고 싶을 때 유용  
							
		* 명시적 형 변환
			- 큰 메모리 값을 작은 메모리로 변환
			- 부동소수점을 정수로 변환
			- 문법 -> 변수(바꾸고자 하는 타입) 변수 또는 값;

	형 변환은 아래 4가지 외에는 불가!
		1) 정수 메모리끼리 형 변환 가능 (숫자 -> 숫자)
		2) 부동소수점을 정수로 형 변환 가능 (숫자 -> 숫자)
		3) 형 변환 없이 정수는 부동소수점 메모리에 저장 가능 (숫자 -> 숫자)
		4) 숫자 -> 문자코드 형 변환 가능

	명시적 형 변환이 불가한 경우,
	특별한 메서드를 사용하면 가능
	
		ex) 
		Boolean.valueOf("true"); -> true
			string -> boolean
		   
		"가".charAt(0); -> 가
			char -> string

		Integer.valueOf("123"); -> 123		* valueOf -> 형 변환 후 객체로 반환
		Integer.parseInt("123") -> 123		  parseInt(Float) -> 원시 데이터 타입으로 변환
			String -> int				-> java 1.5에 도입된 Auto Boxing and Unboxing 덕에 뭘 써도 상관 없음

		Float.valueOf("3.14f") ; -> 3.14
		Float.parseInt("3.14f") ; -> 3.14
			String -> float		

- 산술 연산자
	-> + , - ,* , / , %(나머지)

	- 우선순위
		( )  ---> 후위연산자(a++,a--) ---> 전위연산자 & 단항연산자 ---> *, / , % ---> 비트이동연산자 ---> 관계연산자 ---> 등위연산자 ---> & ---> ^ ---> | ---> && ---> || ---> 삼항연산자 ---> 할당연산자

	- 기본연산 단위
		ex)
			byte b;
			b =5; or b = 6;  --> OK!
			b = 5+6; ---> OK!
		ex)
			byte x=5, y=6; z;
			z=x; --> OK!
			z=y; --> OK!

			z = x + y ; --> 컴파일 오류!!
					-> 정수 연산 시 임시 4바이트에 담아서 연산 후 결과 값을 4바이트에 담아서 보내주기 때문!

		* 작은 숫자를 다루더라도 int로! / byte는 파일의 데이터를 읽어들일 때 사용
	
	- 연산의 결과 타입
		- int 와 int의 연산 결과 => int
		- float 과 float의 연산 결과 => float  ---> float + float 값을 double에 담아도 이미 float으로 계산이 끝났기 때문에 값 오류! 
							-> 연산 전 double로 담은 후 연산!
		- int와 float의 연산결과 => float

		But, 연산의 결과가 해당 type을 넘어서면 의도한 결과가 나오지 않음
			- float 과 float의 연산 결과 => float  ---> float + float 값을 double에 담아도 이미 float으로 계산이 끝났기 때문에 값 오류! 
							-> 연산 전 double로 담은 후 연산!

		* 정리!
			1. 최소 연산 단위 => int
				int보다 작을 경우 int로 자동 형 변환 후 수행! (=암시적 형 변환)
			2. 연산 결과는 항상 피연산자의 타입과 같다.
			3. 다른 타입과 연산을 수행할 때는 내부적으로 같은 타입으로 맞춘 다음에 실행한다.
			4. 정수 + 정수 => 기본값 int (피연산자 중 하나라도 long이라면 long)
			   정수 + 실수 => 실수 (float / double 중 큰 값)

- 관계 연산자
	-> 관계연산자 (< , <=, > , >=) / 등위 연산자 (== , !=)
	    비교의 결과는 True or False

	- 부동소수점 비교
		-> 부동소수점 값을 연산 시 IEEE754 명세에 따라 작업을 수행하는데 이 과정에서 값의 왜곡이 발생할 수 있다.

			ex) double d1 = 987.6543 ;
			     double d2 = 1.111111 ;

			     d1 + d2 = 988.765411 ; -> 기대값
				    = 988.7654110000001 -> 실제값
	
			    double x = 234.765411
			    double y = 754.0
			
			    x + y = 988.765411

			sout((x+y) == (d1+d2)); -> false ;
			
			=> 결과 뒤에 극소수 값이 붙음
				-> 개발자가 직접 처리해야함
					ex) double EPSILON = 0.00001 ;
					     sout(Math.abs((d1+d2)-(x+y)) < EPSILON) ;

							or

					ex) float f1 = 0.1f ; 
					     float f2 = 0.1f;
			
					     f1 * f2 = 0.01f --> 기대값  과 달리 false

					    float r = (f1 * f2) - 0.01f
					    sout(Math.abs(r) <= Float.POSITIVE_INFINITY ; --> 해결책
						
			